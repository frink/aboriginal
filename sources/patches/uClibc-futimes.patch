User Mode Linux needs futimes().

--- uClibc/include/sys/time.h	2005-11-30 11:07:06.000000000 -0600
+++ uClibc2/include/sys/time.h	2009-11-14 04:55:32.000000000 -0600
@@ -143,7 +143,9 @@
 /* Same as `utimes', but does not follow symbolic links.  */
 extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
      __THROW __nonnull ((1));
+#endif
 
+#ifdef __USE_BSD
 /* Same as `utimes', but takes an open file descriptor instead of a name.  */
 extern int futimes (int __fd, __const struct timeval __tvp[2]) __THROW;
 #endif
--- /dev/null	2009-08-01 20:56:12.000000000 -0500
+++ uClibc2/libc/sysdeps/linux/common/futimes.c	2009-11-14 04:53:49.000000000 -0600
@@ -0,0 +1,39 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * futimes() for uClibc
+ *
+ * Copyright (C) 2009 Rob Landley <rob@landley.net>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#define _SYSCALL_H
+#include <bits/syscalls.h>
+#include <utime.h>
+#include <sys/time.h>
+
+#ifdef __NR_utimensat
+libc_hidden_proto(futimes)
+
+int futimes(const int fd, const struct timeval tvp[2])
+{
+	struct timespec ts[2], *pts = ts;
+	int ret;
+	INTERNAL_SYSCALL_DECL(err);
+
+	/* Convert timeval to timespec, for syscall */
+
+	if (tvp) {
+		TIMEVAL_TO_TIMESPEC(tvp, ts);
+		TIMEVAL_TO_TIMESPEC(tvp+1, ts+1);
+	} else pts = 0;
+
+	/* Make syscall */
+
+	ret = INTERNAL_SYSCALL_NCS(utimensat, dummy, 4, fd, 0, pts, 0);
+	if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+		return INTERNAL_SYSCALL_ERRNO (ret, err);
+	return 0;
+}
+libc_hidden_def(futimes)
+#endif
