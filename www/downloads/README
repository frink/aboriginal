The downloads directory contains the Firmware Linux build scripts, which is
the source code for the FWL project.  If you would like to build your own
cross compiler or target system image from source, use these build scripts.
They're written in bash and should be fairly easy to read.

If you want to download prebuilt binary cross compilers or system images,
see the downloads/binaries directory (which has its own README).

These scripts include the following stages:

  build.sh ARCH

    Top level wrapper script, calls the others in sequence.  Requires one
    argument, which is the target platform to build for.  When run without
    arguments, it lists available architectures.

    Several environment variables can be set to control its behavior, see
    the file "configure" for details.

    You can invoke the other scripts in sequence if you like, but this is
    generally the one you use to do everything else.

  download.sh

    Uses wget to download the source code required by the later build stages,
    saving it in the "packages" directory.  It compares the sha1 checksum
    of any existing tarballs to an expected value, only downloading new
    source tarballs when it needs to.

    If the primary site is down, it checks a series of fallback mirrors.
    The environment variable PREFERRED_MIRROR can insert a new mirror at
    the start of the list, which is checked before even the official website.

    This script is not target-specific, and only needs to be called once
    when building multiple architectures.

  host-tools.sh

    Sanitizes the host environment by building known versions of needed tools
    from source code, then restricting the $PATH to just those tools.  This is
    an optional step which can be skipped, but without it the build process
    is very brittle.

    This step serves a similar purpose to the temporary system built by Linux
    From Scratch's chapter 5, isolating the new system from variations in the
    host.  It also acts as an early check that the resulting system images
    offer a sufficient development environment to rebuild themselves from
    source, because the host tool versions used to build them in the first
    place are the same ones the scripts install into the target root filesystem.

    This script populates the "build/host" directory, which is automatically
    used by later stages if it exists.  It is not target specific, and only
    needs to be run once when building multiple architectures.

  cross-compiler.sh ARCH

    Creates a cross compiler for the selected target architecture, built from
    gcc, binutils, uClibc, and the Linux kernel headers.

    The resulting compiler is assembled in build/cross-compiler-ARCH and
    then packaged as an adjacent tarball of the same name.

  root-filesystem.sh ARCH

    Creates a root filesystem mfor the target, built from busybox and
    uClibc.  Adds to it a native compiler built from the same packages as
    the cross compiler, plus the packages make, bash, and distcc.

    This step uses the cross compiler built in the previous step.  It
    assembles the new filesystem in the build/root-filesystem-ARCH directory,
    then packages it as an adjacent tarball of the same name.

  system-image.sh ARCH

    Package up the root filesystem into a filesystem image (ext2, squashfs,
    or initramfs), build a Linux kernel configured for the target, and
    generate a wrapper script capable of invoking an appropriate emulator
    (generally qemu).

    The system images are generated in build/system-image-ARCH directory,
    and packaged as a tarball of the same name.

  run-from-build.sh ARCH

    Boot up a system image under its emulator, with full native development
    environment options (a 2 gigabyte /dev/hdb mounted on /home and distcc
    calling out to the appropriate cross compiler).

    Note that targets with the hw- prefix are aimed at actual hardware, and do
    not have an emulator configured.  Hardware targets are derived from an
    existing architecture, repackaging the other architecture's root filesystem
    with a different Linux kernel configuration.

The wrapper script buildall.sh runs build.sh on every available target,
with extra configure options to produce additional optional stages such as
statically linked cross and native compilers.
